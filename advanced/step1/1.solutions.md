# Step 1: Authentication and Authorization

## Objective
Implement secure user authentication and role-based authorization for your ML API to control access to different endpoints and features.

## Context
As your ML API moves into production environments, it becomes essential to control who can access it and what actions they can perform. Authentication verifies user identity, while authorization determines what resources authenticated users can access. This step will teach you how to implement both using industry-standard JWT (JSON Web Token) authentication.

## Why it is required
- **Data Security**: Prevents unauthorized access to sensitive prediction endpoints and data
- **Access Control**: Different users need different levels of access (admins, data scientists, regular users)
- **Audit Trail**: Authentication enables tracking who made specific requests
- **API Monetization**: Enables building subscription tiers with different access levels
- **Regulatory Compliance**: Many industries require access controls for ML systems

## How to achieve this

### 1. Set up the user model and database

Create a file `app/models/user.py`:

```python
from datetime import datetime
from enum import Enum
from typing import Optional, List
from pydantic import BaseModel, EmailStr, Field, validator
import re

class UserRole(str, Enum):
    ADMIN = "admin"
    DATA_SCIENTIST = "data_scientist"
    USER = "user"

class UserCreate(BaseModel):
    email: EmailStr
    username: str = Field(..., min_length=3, max_length=50)
    password: str = Field(..., min_length=8)
    role: UserRole = UserRole.USER
    
    @validator('password')
    def password_strength(cls, v):
        """Validate password strength"""
        if not re.search(r'[A-Z]', v):
            raise ValueError('Password must contain at least one uppercase letter')
        if not re.search(r'[a-z]', v):
            raise ValueError('Password must contain at least one lowercase letter')
        if not re.search(r'[0-9]', v):
            raise ValueError('Password must contain at least one digit')
        if not re.search(r'[^A-Za-z0-9]', v):
            raise ValueError('Password must contain at least one special character')
        return v

class UserResponse(BaseModel):
    id: int
    email: EmailStr
    username: str
    role: UserRole
    created_at: datetime
    is_active: bool

class UserInDB(UserResponse):
    hashed_password: str

class UserLogin(BaseModel):
    email: EmailStr
    password: str

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    email: Optional[str] = None
    role: Optional[UserRole] = None
```

Create a database module `app/db/database.py` with enhanced error handling and logging:

```python
import os
import logging
from sqlalchemy import create_engine, Column, Integer, String, Boolean, DateTime, Enum, MetaData, Table
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from sqlalchemy.sql import func
from sqlalchemy.exc import OperationalError

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Configure SQLAlchemy
DB_FILE = "./app.db"
SQLALCHEMY_DATABASE_URL = os.getenv("DATABASE_URL", f"sqlite:///{DB_FILE}")

# Log database location
logger.info(f"Using database: {SQLALCHEMY_DATABASE_URL}")
logger.info(f"Database file path: {os.path.abspath(DB_FILE)}")

# Create engine with echo for debugging
engine = create_engine(
    SQLALCHEMY_DATABASE_URL, 
    connect_args={"check_same_thread": False}
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

# Import here to avoid circular imports
from app.models.user import UserRole

# Define SQLAlchemy models
class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True)
    username = Column(String, unique=True, index=True)
    hashed_password = Column(String)
    role = Column(String)  # Store as string for compatibility
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

# Create tables
def create_tables():
    """Create database tables with error handling"""
    try:
        logger.info("Attempting to create database tables...")
        
        # Check if database file exists or can be created
        db_dir = os.path.dirname(os.path.abspath(DB_FILE))
        if not os.path.exists(db_dir):
            os.makedirs(db_dir)
            logger.info(f"Created directory: {db_dir}")
        
        # Create using SQLAlchemy declarative Base
        Base.metadata.create_all(bind=engine)
        
        # Verify the users table exists
        metadata = MetaData()
        metadata.reflect(bind=engine)
        if 'users' in metadata.tables:
            logger.info("Users table exists!")
        else:
            logger.error("Users table was not created!")
            
            # Try direct table creation as fallback
            users = Table(
                "users",
                metadata,
                Column("id", Integer, primary_key=True),
                Column("email", String, unique=True, index=True),
                Column("username", String, unique=True, index=True),
                Column("hashed_password", String),
                Column("role", String),
                Column("is_active", Boolean, default=True),
                Column("created_at", DateTime, server_default=func.now()),
                Column("updated_at", DateTime)
            )
            metadata.create_all(engine)
            logger.info("Created users table directly")

        logger.info("Database tables created successfully")
        return True
    except Exception as e:
        logger.error(f"Error creating database tables: {e}")
        # Don't suppress the exception so we can see it in logs
        raise

# Dependency to get database session
def get_db():
    """Get database session with retry for connection issues"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

### 1.1 Create a database initialization script

Create a file called `init_db.py` in your project root to initialize the database and create a default admin user:

```python
import os
import sys

# Add the project root to sys.path to allow importing from app
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from app.db.database import engine, Base, User
from app.utils.security import get_password_hash
from app.models.user import UserRole

def init_database():
    print("Creating database tables...")
    # Create all tables
    Base.metadata.create_all(bind=engine)
    
    # Verify users table exists
    from sqlalchemy import inspect
    inspector = inspect(engine)
    tables = inspector.get_table_names()
    print(f"Tables in database: {tables}")
    
    if "users" in tables:
        print("Users table created successfully!")
    else:
        print("ERROR: Users table was not created!")

    # Create a default admin user
    from sqlalchemy.orm import Session
    with Session(engine) as session:
        # Check if admin user already exists
        admin = session.query(User).filter(User.email == "admin@example.com").first()
        if not admin:
            print("Creating default admin user...")
            admin_user = User(
                email="admin@example.com",
                username="admin",
                hashed_password=get_password_hash("AdminP@ss123"),
                role="admin"  # Store as string
            )
            session.add(admin_user)
            session.commit()
            print("Default admin user created.")
        else:
            print("Admin user already exists.")

if __name__ == "__main__":
    init_database()
```

You should run this script before starting your application for the first time to ensure the database and tables are properly created:

```bash
python init_db.py
```

### 2. Implement authentication utilities

Create a security utilities file `app/utils/security.py`:

```python
from datetime import datetime, timedelta
from typing import Optional
from jose import JWTError, jwt
from passlib.context import CryptContext
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.orm import Session
from app.db.database import get_db, User
from app.models.user import TokenData, UserRole

# Security configuration
SECRET_KEY = "YOUR_SECRET_KEY_HERE"  # In production, use a strong, random secret key stored securely
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# Password hashing
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# OAuth2 password bearer scheme
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="auth/token")

# Password utilities
def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

# JWT token utilities
def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

# User authentication
def get_user(db: Session, email: str):
    return db.query(User).filter(User.email == email).first()

def authenticate_user(db: Session, email: str, password: str):
    user = get_user(db, email)
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user

# Token validation and user extraction
async def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        email: str = payload.get("sub")
        if email is None:
            raise credentials_exception
        token_data = TokenData(email=email)
    except JWTError:
        raise credentials_exception
    user = get_user(db, email=token_data.email)
    if user is None:
        raise credentials_exception
    return user

# Role-based access control
def get_current_active_user(current_user = Depends(get_current_user)):
    if not current_user.is_active:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user

def check_admin_role(current_user = Depends(get_current_active_user)):
    if current_user.role != UserRole.ADMIN:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not authorized to perform this action"
        )
    return current_user

def check_data_scientist_role(current_user = Depends(get_current_active_user)):
    allowed_roles = [UserRole.ADMIN, UserRole.DATA_SCIENTIST]
    if current_user.role not in allowed_roles:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not authorized to perform this action"
        )
    return current_user
```

### 3. Create authentication endpoints

Create a file `app/api/auth.py`:

```python
from datetime import timedelta
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session

from app.db.database import get_db, User
from app.models.user import UserCreate, UserResponse, Token
from app.utils.security import (
    authenticate_user, create_access_token, get_password_hash,
    get_current_active_user, ACCESS_TOKEN_EXPIRE_MINUTES
)

router = APIRouter(prefix="/auth", tags=["Authentication"])

@router.post("/register", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
def register_user(user_data: UserCreate, db: Session = Depends(get_db)):
    """
    Register a new user
    """
    # Check if user already exists
    if db.query(User).filter(User.email == user_data.email).first():
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered"
        )
    
    if db.query(User).filter(User.username == user_data.username).first():
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Username already taken"
        )
    
    # Create new user
    db_user = User(
        email=user_data.email,
        username=user_data.username,
        hashed_password=get_password_hash(user_data.password),
        role=user_data.role
    )
    
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    
    return db_user

@router.post("/token", response_model=Token)
def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):
    """
    Authenticate and generate JWT token
    """
    user = authenticate_user(db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.email, "role": user.role}, 
        expires_delta=access_token_expires
    )
    
    return {"access_token": access_token, "token_type": "bearer"}

@router.get("/me", response_model=UserResponse)
def read_users_me(current_user = Depends(get_current_active_user)):
    """
    Get current authenticated user information
    """
    return current_user
```

### 4. Update the main app to use authentication

Update `app/main.py` to include the authentication router and enhanced database setup:

```python
from fastapi import FastAPI, Depends, Request
from fastapi.middleware.cors import CORSMiddleware
import logging

from app.api import endpoints  # Your existing endpoints
from app.api import auth       # New auth module
from app.db.database import create_tables
from app.utils.security import get_current_active_user, check_admin_role, check_data_scientist_role

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Create FastAPI app
app = FastAPI(
    title="Secure ML API",
    description="Machine Learning API with authentication and authorization",
    version="1.0.0"
)

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, specify exact origins
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Create database tables on startup with enhanced error handling
@app.on_event("startup")
async def startup_event():
    logger.info("Application starting up...")
    try:
        # Create database tables
        create_tables()
        logger.info("Database initialization complete")
    except Exception as e:
        logger.critical(f"Failed to initialize database: {e}")
        # Log the error but continue startup to avoid application failure
        # In production, you might want to exit here depending on your requirements

# Include routers
app.include_router(auth.router)

# Include existing endpoints with authentication
app.include_router(
    endpoints.router,
    dependencies=[Depends(get_current_active_user)]  # All endpoints require authentication
)

# Add protected admin endpoints
@app.get("/admin", tags=["Admin"])
def admin_endpoint(current_user = Depends(check_admin_role)):
    """Endpoint only accessible to administrators"""
    return {"message": f"Hello admin {current_user.username}!"}

# Add protected data scientist endpoints
@app.get("/models/evaluate", tags=["Model Management"])
def evaluate_model(current_user = Depends(check_data_scientist_role)):
    """Endpoint accessible to data scientists and admins"""
    return {"message": f"Hello {current_user.role} {current_user.username}!"}
```

### 5. Protect your existing prediction endpoint

Update your existing prediction endpoint in `app/api/endpoints.py`:

```python
from fastapi import Depends
from app.utils.security import get_current_active_user, check_data_scientist_role
import logging

# Create logger for this module
logger = logging.getLogger(__name__)

# Public endpoint with rate limiting
@router.get("/info", summary="API Information")
async def info():
    """Returns information about the API (public endpoint)"""
    return {
        "name": "Secure ML API",
        "version": "1.0.0",
        "models": ["iris"]
    }

# Protected endpoint requiring authentication
@router.post(
    "/predict", 
    response_model=PredictionResponse, 
    summary="Make a prediction", 
    tags=["Prediction"]
)
async def predict(
    features: IrisFeatures,
    model_service: ModelService = Depends(get_model_service),
    current_user = Depends(get_current_active_user)  # Require authentication
):
    """Make a prediction based on the provided iris features (authenticated endpoint)"""
    # Log which user is making the prediction
    logger.info(f"User {current_user.username} ({current_user.email}) made a prediction")
    
    # Continue with your existing prediction code
    try:
        # Convert to numpy array in the expected format
        input_features = np.array([
            [
                features.sepal_length, 
                features.sepal_width, 
                features.petal_length, 
                features.petal_width
            ]
        ])
        
        # Make prediction
        result = model_service.predict(input_features)
        return result
    except ValueError as e:
        # Handle validation errors
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        # Handle other errors
        logger.error(f"Prediction error: {str(e)}")
        raise HTTPException(status_code=500, detail="Prediction error")

# Admin-only endpoint for model management
@router.post(
    "/models/retrain",
    summary="Retrain the model",
    tags=["Model Management"]
)
async def retrain_model(
    model_name: str,
    model_service: ModelService = Depends(get_model_service),
    current_user = Depends(check_data_scientist_role)  # Require data scientist or admin role
):
    """Retrain the specified model (data scientist/admin only)"""
    # Your model retraining code here
    return {"message": f"Model {model_name} retraining initiated by {current_user.username}"}
```

## Examples of usage

### 1. Database Initialization

Before using the API, you should initialize the database by running the initialization script:

```bash
# Initialize the database and create a default admin user
python init_db.py

# Expected output:
# Creating database tables...
# Tables in database: ['users']
# Users table created successfully!
# Creating default admin user...
# Default admin user created.
```

### 2. User Registration

```python
import requests

# First, make sure the API is running and the database is initialized

# Register a new user
response = requests.post(
    "http://localhost:8000/auth/register",
    json={
        "email": "user@example.com",
        "username": "testuser",
        "password": "SecureP@ss123",
        "role": "user"
    }
)

print("Registration Response:", response.status_code)
print(response.json())
```

### 3. User Authentication and Token Retrieval

```python
import requests

# Authenticate and get token
response = requests.post(
    "http://localhost:8000/auth/token",
    data={
        "username": "user@example.com",  # Using email as username
        "password": "SecureP@ss123"
    }
)

print("Authentication Response:", response.status_code)
token_data = response.json()
print(token_data)

# Save token for subsequent requests
access_token = token_data["access_token"]
```

You can also authenticate using the default admin user created by the initialization script:

```python
import requests

# Authenticate with the admin user
response = requests.post(
    "http://localhost:8000/auth/token",
    data={
        "username": "admin@example.com",
        "password": "AdminP@ss123"  # Password set in init_db.py
    }
)

print("Admin Authentication Response:", response.status_code)
admin_token_data = response.json()
print(admin_token_data)

# Save admin token for admin operations
admin_token = admin_token_data["access_token"]
```

### 4. Making Authenticated API Requests

```python
import requests

# Use the token for authenticated requests
headers = {
    "Authorization": f"Bearer {access_token}"
}

# Get user info
response = requests.get(
    "http://localhost:8000/auth/me",
    headers=headers
)

print("User Info Response:", response.status_code)
print(response.json())

# Make a prediction (authenticated)
prediction_response = requests.post(
    "http://localhost:8000/predict",
    headers=headers,
    json={
        "sepal_length": 5.1,
        "sepal_width": 3.5,
        "petal_length": 1.4,
        "petal_width": 0.2
    }
)

print("Prediction Response:", prediction_response.status_code)
print(prediction_response.json())

# Try to access admin endpoint (will fail for regular user)
admin_response = requests.get(
    "http://localhost:8000/admin",
    headers=headers
)

print("Admin Access Response:", admin_response.status_code)
print(admin_response.json())
```

### 5. Complete Authentication Flow Example

Here's a complete example script demonstrating the entire authentication flow:

```python
import requests
import time

# Wait a moment to ensure the API is running
print("Connecting to the API...")
time.sleep(1)

# 1. Check if API is available
try:
    health_check = requests.get("http://localhost:8000/info")
    print(f"API Health check: {health_check.status_code}")
except Exception as e:
    print(f"Error accessing API: {e}")
    exit(1)

# 2. Register a new user
print("\nRegistering new user...")
response = requests.post(
    "http://localhost:8000/auth/register",
    json={
        "email": "test@example.com",
        "username": "testuser2",
        "password": "SecureP@ss123",
        "role": "user"
    }
)

print(f"Registration Response: {response.status_code}")
if response.status_code == 201:
    print("User registered successfully!")
    user_data = response.json()
    print(f"User ID: {user_data['id']}")
    print(f"Username: {user_data['username']}")
    print(f"Role: {user_data['role']}")
else:
    # The user might already exist, which is fine for this example
    print(f"Registration note: {response.json()}")

# 3. Authenticate and get token
print("\nAuthenticating user...")
auth_response = requests.post(
    "http://localhost:8000/auth/token",
    data={
        "username": "test@example.com",
        "password": "SecureP@ss123"
    }
)

print(f"Authentication Response: {auth_response.status_code}")
if auth_response.status_code == 200:
    token_data = auth_response.json()
    access_token = token_data["access_token"]
    print(f"Received token: {access_token[:10]}...")  # Show just the beginning
    
    # 4. Access protected endpoint
    print("\nAccessing protected endpoint...")
    headers = {"Authorization": f"Bearer {access_token}"}
    
    me_response = requests.get(
        "http://localhost:8000/auth/me",
        headers=headers
    )
    
    print(f"Protected endpoint response: {me_response.status_code}")
    if me_response.status_code == 200:
        print("Authentication successful!")
        print(f"User data: {me_response.json()}")
    else:
        print(f"Error: {me_response.json()}")
else:
    print(f"Authentication failed: {auth_response.json()}")
```

## Tasks for students

1. **Implement User Management with Password Hashing**
   - Create a user database model with roles (admin, data scientist, user)
   - Implement secure password hashing with bcrypt
   - Add endpoints for user registration and information retrieval

2. **Add JWT-based Authentication**
   - Create JWT token generation and validation functionality
   - Implement login endpoint that returns JWT tokens
   - Add middleware to validate tokens on protected endpoints

3. **Implement Role-based Authorization**
   - Create a role-based authorization system
   - Protect admin endpoints to be accessible only by admin users
   - Make prediction endpoints require authentication
   - Create a data scientist role with special model management privileges

## Solution (for instructors)

### Solution for Task 1: User Management Implementation

The key points to evaluate in student solutions:

1. User model with proper fields (email, username, hashed_password, role)
2. Secure password hashing using bcrypt
3. Input validation for user registration
4. Proper error handling for duplicate emails/usernames

Students should have implemented the User model with the SQLAlchemy ORM and created Pydantic models for validation. Their password hashing should use a secure algorithm like bcrypt, and their user registration endpoint should check for existing users to avoid duplicates.

### Solution for Task 2: JWT Authentication

The key points to evaluate in student solutions:

1. JWT token generation with proper expiration
2. Token validation middleware
3. Secure storage of JWT secret key
4. Proper error responses for invalid tokens

Students should have created functions to generate and validate JWT tokens, implemented a login endpoint that returns tokens, and created dependencies to validate tokens on protected endpoints.

### Solution for Task 3: Role-based Authorization

The key points to evaluate in student solutions:

1. Role-checking dependencies for different access levels
2. Proper HTTP 403 responses for unauthorized access
3. Application of role checks to appropriate endpoints
4. Clear separation of admin, data scientist, and user privileges

Students should have created role-based dependencies that check the user's role before allowing access to protected endpoints, and they should have applied these dependencies to the appropriate endpoints.

### Complete Authentication Script

```python
"""
Complete solution script for authentication and authorization implementation
"""

# ----- init_db.py -----
import os
import sys

# Add the project root to sys.path to allow importing from app
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from app.db.database import engine, Base, User
from app.utils.security import get_password_hash
from app.models.user import UserRole

def init_database():
    print("Creating database tables...")
    # Create all tables
    Base.metadata.create_all(bind=engine)
    
    # Verify users table exists
    from sqlalchemy import inspect
    inspector = inspect(engine)
    tables = inspector.get_table_names()
    print(f"Tables in database: {tables}")
    
    if "users" in tables:
        print("Users table created successfully!")
    else:
        print("ERROR: Users table was not created!")

    # Create a default admin user
    from sqlalchemy.orm import Session
    with Session(engine) as session:
        # Check if admin user already exists
        admin = session.query(User).filter(User.email == "admin@example.com").first()
        if not admin:
            print("Creating default admin user...")
            admin_user = User(
                email="admin@example.com",
                username="admin",
                hashed_password=get_password_hash("AdminP@ss123"),
                role="admin"  # Store as string
            )
            session.add(admin_user)
            session.commit()
            print("Default admin user created.")
        else:
            print("Admin user already exists.")

if __name__ == "__main__":
    init_database()

# ----- app/models/user.py -----
from datetime import datetime
from enum import Enum
from typing import Optional, List
from pydantic import BaseModel, EmailStr, Field, validator
import re

class UserRole(str, Enum):
    ADMIN = "admin"
    DATA_SCIENTIST = "data_scientist"
    USER = "user"

class UserCreate(BaseModel):
    email: EmailStr
    username: str = Field(..., min_length=3, max_length=50)
    password: str = Field(..., min_length=8)
    role: UserRole = UserRole.USER
    
    @validator('password')
    def password_strength(cls, v):
        """Validate password strength"""
        if not re.search(r'[A-Z]', v):
            raise ValueError('Password must contain at least one uppercase letter')
        if not re.search(r'[a-z]', v):
            raise ValueError('Password must contain at least one lowercase letter')
        if not re.search(r'[0-9]', v):
            raise ValueError('Password must contain at least one digit')
        if not re.search(r'[^A-Za-z0-9]', v):
            raise ValueError('Password must contain at least one special character')
        return v

class UserResponse(BaseModel):
    id: int
    email: EmailStr
    username: str
    role: UserRole
    created_at: datetime
    is_active: bool

class UserInDB(UserResponse):
    hashed_password: str

class UserLogin(BaseModel):
    email: EmailStr
    password: str

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    email: Optional[str] = None
    role: Optional[UserRole] = None

# ----- app/db/database.py -----
import os
import logging
from sqlalchemy import create_engine, Column, Integer, String, Boolean, DateTime, Enum, MetaData, Table
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from sqlalchemy.sql import func
from sqlalchemy.exc import OperationalError

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Configure SQLAlchemy
DB_FILE = "./app.db"
SQLALCHEMY_DATABASE_URL = os.getenv("DATABASE_URL", f"sqlite:///{DB_FILE}")

# Log database location
logger.info(f"Using database: {SQLALCHEMY_DATABASE_URL}")
logger.info(f"Database file path: {os.path.abspath(DB_FILE)}")

# Create engine with echo for debugging
engine = create_engine(
    SQLALCHEMY_DATABASE_URL, 
    connect_args={"check_same_thread": False}
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

# Import here to avoid circular imports
from app.models.user import UserRole

# Define SQLAlchemy models
class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True)
    username = Column(String, unique=True, index=True)
    hashed_password = Column(String)
    role = Column(String)  # Store as string for compatibility
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

# Create tables
def create_tables():
    """Create database tables with error handling"""
    try:
        logger.info("Attempting to create database tables...")
        
        # Check if database file exists or can be created
        db_dir = os.path.dirname(os.path.abspath(DB_FILE))
        if not os.path.exists(db_dir):
            os.makedirs(db_dir)
            logger.info(f"Created directory: {db_dir}")
        
        # Create using SQLAlchemy declarative Base
        Base.metadata.create_all(bind=engine)
        
        # Verify the users table exists
        metadata = MetaData()
        metadata.reflect(bind=engine)
        if 'users' in metadata.tables:
            logger.info("Users table exists!")
        else:
            logger.error("Users table was not created!")
            
            # Try direct table creation as fallback
            users = Table(
                "users",
                metadata,
                Column("id", Integer, primary_key=True),
                Column("email", String, unique=True, index=True),
                Column("username", String, unique=True, index=True),
                Column("hashed_password", String),
                Column("role", String),
                Column("is_active", Boolean, default=True),
                Column("created_at", DateTime, server_default=func.now()),
                Column("updated_at", DateTime)
            )
            metadata.create_all(engine)
            logger.info("Created users table directly")

        logger.info("Database tables created successfully")
        return True
    except Exception as e:
        logger.error(f"Error creating database tables: {e}")
        # Don't suppress the exception so we can see it in logs
        raise

# Dependency to get database session
def get_db():
    """Get database session with retry for connection issues"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# ----- app/utils/security.py -----
from datetime import datetime, timedelta
from typing import Optional
from jose import JWTError, jwt
from passlib.context import CryptContext
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.orm import Session
from app.db.database import get_db, User
from app.models.user import TokenData, UserRole

# Security configuration
SECRET_KEY = "YOUR_SECRET_KEY_HERE"  # In production, use a strong, random secret key stored securely
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# Password hashing
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# OAuth2 password bearer scheme
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="auth/token")

# Password utilities
def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

# JWT token utilities
def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

# User authentication
def get_user(db: Session, email: str):
    return db.query(User).filter(User.email == email).first()

def authenticate_user(db: Session, email: str, password: str):
    user = get_user(db, email)
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user

# Token validation and user extraction
async def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        email: str = payload.get("sub")
        if email is None:
            raise credentials_exception
        token_data = TokenData(email=email)
    except JWTError:
        raise credentials_exception
    user = get_user(db, email=token_data.email)
    if user is None:
        raise credentials_exception
    return user

# Role-based access control
def get_current_active_user(current_user = Depends(get_current_user)):
    if not current_user.is_active:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user

def check_admin_role(current_user = Depends(get_current_active_user)):
    if current_user.role != UserRole.ADMIN:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not authorized to perform this action"
        )
    return current_user

def check_data_scientist_role(current_user = Depends(get_current_active_user)):
    allowed_roles = [UserRole.ADMIN, UserRole.DATA_SCIENTIST]
    if current_user.role not in allowed_roles:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not authorized to perform this action"
        )
    return current_user

# ----- app/api/auth.py -----
from datetime import timedelta
from fastapi import APIRouter, Depends, HTTPException, status, Request
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
import logging

from app.db.database import get_db, User
from app.models.user import UserCreate, UserResponse, Token
from app.utils.security import (
    authenticate_user, create_access_token, get_password_hash,
    get_current_active_user, ACCESS_TOKEN_EXPIRE_MINUTES
)

# Create logger
logger = logging.getLogger(__name__)
security_logger = logging.getLogger("security")

router = APIRouter(prefix="/auth", tags=["Authentication"])

@router.post("/register", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
def register_user(user_data: UserCreate, db: Session = Depends(get_db)):
    """
    Register a new user
    """
    # Check if user already exists
    if db.query(User).filter(User.email == user_data.email).first():
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered"
        )
    
    if db.query(User).filter(User.username == user_data.username).first():
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Username already taken"
        )
    
    # Create new user
    db_user = User(
        email=user_data.email,
        username=user_data.username,
        hashed_password=get_password_hash(user_data.password),
        role=user_data.role
    )
    
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    
    # Log user creation
    security_logger.info(f"New user registered: {user_data.username} ({user_data.email}) with role {user_data.role}")
    
    return db_user

@router.post("/token", response_model=Token)
def login_for_access_token(request: Request, form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):
    """
    Authenticate and generate JWT token
    """
    # Get client IP for logging
    client_ip = request.client.host
    
    # Authenticate user
    user = authenticate_user(db, form_data.username, form_data.password)
    
    # Log authentication attempt
    if user:
        security_logger.info(f"Successful login: user={form_data.username}, ip={client_ip}")
    else:
        security_logger.warning(f"Failed login attempt: user={form_data.username}, ip={client_ip}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # Generate token
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.email, "role": user.role}, 
        expires_delta=access_token_expires
    )
    
    return {"access_token": access_token, "token_type": "bearer"}

@router.get("/me", response_model=UserResponse)
def read_users_me(current_user = Depends(get_current_active_user)):
    """
    Get current authenticated user information
    """
    return current_user

# ----- app/main.py -----
from fastapi import FastAPI, Depends, Request
from fastapi.middleware.cors import CORSMiddleware
import logging

from app.api import endpoints  # Your existing endpoints
from app.api import auth       # New auth module
from app.db.database import create_tables
from app.utils.security import get_current_active_user, check_admin_role, check_data_scientist_role

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Create FastAPI app
app = FastAPI(
    title="Secure ML API",
    description="Machine Learning API with authentication and authorization",
    version="1.0.0"
)

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, specify exact origins
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Create database tables on startup with enhanced error handling
@app.on_event("startup")
async def startup_event():
    logger.info("Application starting up...")
    try:
        # Create database tables
        create_tables()
        logger.info("Database initialization complete")
    except Exception as e:
        logger.critical(f"Failed to initialize database: {e}")
        # Log the error but continue startup to avoid application failure
        # In production, you might want to exit here depending on your requirements

# Include routers
app.include_router(auth.router)

# Include existing endpoints with authentication
app.include_router(
    endpoints.router,
    dependencies=[Depends(get_current_active_user)]  # All endpoints require authentication
)

# Add protected admin endpoints
@app.get("/admin", tags=["Admin"])
def admin_endpoint(current_user = Depends(check_admin_role)):
    """Endpoint only accessible to administrators"""
    return {"message": f"Hello admin {current_user.username}!"}

# Add protected data scientist endpoints
@app.get("/models/evaluate", tags=["Model Management"])
def evaluate_model(current_user = Depends(check_data_scientist_role)):
    """Endpoint accessible to data scientists and admins"""
    return {"message": f"Hello {current_user.role} {current_user.username}!"}
```