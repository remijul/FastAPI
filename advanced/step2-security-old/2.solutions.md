# Step 2: API Security Best Practices (OWASP Top 10)

## Objective
Implement security best practices based on the OWASP API Security Top 10 to protect your ML API from common vulnerabilities and attacks.

## Context
As your API becomes publicly accessible, it becomes a potential target for various security threats. The OWASP (Open Web Application Security Project) API Security Top 10 provides a framework for addressing the most critical security risks for APIs. In this step, you'll implement defenses against these risks.

## Why it is required
- **Prevent Data Breaches**: Protect sensitive model data and user information
- **Maintain Service Availability**: Prevent denial-of-service attacks that could take down your API
- **Protect API Integrity**: Ensure predictions and model outputs cannot be tampered with
- **Build User Trust**: Security is essential for user confidence in your API
- **Regulatory Compliance**: Many industries have security requirements for ML systems
- **Mitigate Financial Risk**: Security breaches can lead to significant financial losses

## How to achieve this

### 1. Implement request validation and sanitization

Update your Pydantic models to include more robust validation in `app/models/models.py`:

```python
from pydantic import BaseModel, Field, validator, confloat
from typing import List, Dict, Any, Optional
import re

class IrisFeatures(BaseModel):
    """Input features for Iris prediction"""
    sepal_length: confloat(gt=0, lt=15) = Field(..., description="Sepal length in cm")
    sepal_width: confloat(gt=0, lt=15) = Field(..., description="Sepal width in cm")
    petal_length: confloat(gt=0, lt=15) = Field(..., description="Petal length in cm")
    petal_width: confloat(gt=0, lt=15) = Field(..., description="Petal width in cm")
    
    @validator('*')
    def check_realistic_values(cls, v, values, **kwargs):
        """Ensure values are within realistic ranges for iris flowers"""
        field = kwargs['field'].name
        
        # Check combinations of values for biological plausibility
        if field == 'petal_width' and 'petal_length' in values:
            if v > values['petal_length']:
                raise ValueError('Petal width cannot be greater than petal length')
        
        if field == 'sepal_width' and 'sepal_length' in values:
            if v > values['sepal_length'] * 2:
                raise ValueError('Sepal width is unrealistically large compared to length')
                
        return v
    
    class Config:
        schema_extra = {
            "example": {
                "sepal_length": 5.1,
                "sepal_width": 3.5,
                "petal_length": 1.4,
                "petal_width": 0.2
            }
        }

class BatchPredictionRequest(BaseModel):
    """Batch prediction request"""
    instances: List[IrisFeatures] = Field(..., min_items=1, max_items=100)
    
    class Config:
        schema_extra = {
            "example": {
                "instances": [
                    {
                        "sepal_length": 5.1,
                        "sepal_width": 3.5,
                        "petal_length": 1.4,
                        "petal_width": 0.2
                    },
                    {
                        "sepal_length": 6.3,
                        "sepal_width": 3.3,
                        "petal_length": 4.7,
                        "petal_width": 1.6
                    }
                ]
            }
        }
```

### 2. Implement security headers middleware

Create a file `app/middleware/security.py`:

```python
from fastapi import Request
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import Response
import time
import uuid

class SecurityHeadersMiddleware(BaseHTTPMiddleware):
    """Middleware to add security headers to responses"""
    
    async def dispatch(self, request: Request, call_next):
        # Process the request
        response = await call_next(request)
        
        # Add security headers
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains"
        response.headers["Content-Security-Policy"] = "default-src 'self'"
        
        return response

class RequestIdMiddleware(BaseHTTPMiddleware):
    """Middleware to add unique request IDs for tracking"""
    
    async def dispatch(self, request: Request, call_next):
        # Generate unique request ID
        request_id = str(uuid.uuid4())
        
        # Add request ID to request state
        request.state.request_id = request_id
        
        # Process the request
        response = await call_next(request)
        
        # Add request ID to response headers
        response.headers["X-Request-ID"] = request_id
        
        return response

class TimingMiddleware(BaseHTTPMiddleware):
    """Middleware to add server timing headers"""
    
    async def dispatch(self, request: Request, call_next):
        # Record start time
        start_time = time.time()
        
        # Process the request
        response = await call_next(request)
        
        # Calculate processing time
        process_time = time.time() - start_time
        
        # Add timing header
        response.headers["Server-Timing"] = f"total;dur={process_time*1000:.2f}"
        
        return response
```

### 3. Implement rate limiting middleware

Create a file `app/middleware/rate_limit.py`:

```python
from fastapi import Request, HTTPException
from starlette.middleware.base import BaseHTTPMiddleware
import time
import logging
from collections import defaultdict
import threading

logger = logging.getLogger(__name__)

class RateLimiter:
    """Rate limiting implementation using sliding window"""
    
    def __init__(self, rate_limit, time_window):
        """
        Initialize rate limiter
        
        Args:
            rate_limit: Maximum number of requests allowed in the time window
            time_window: Time window in seconds
        """
        self.rate_limit = rate_limit
        self.time_window = time_window
        self.requests = defaultdict(list)  # client_identifier -> list of request timestamps
        self.lock = threading.Lock()
    
    def is_rate_limited(self, client_identifier):
        """
        Check if client is rate limited
        
        Args:
            client_identifier: Unique client identifier (e.g., IP address)
            
        Returns:
            tuple: (is_limited, current_count, limit)
        """
        with self.lock:
            # Get current time
            current_time = time.time()
            
            # Clean up old requests
            self.requests[client_identifier] = [
                timestamp for timestamp in self.requests[client_identifier] 
                if current_time - timestamp < self.time_window
            ]
            
            # Check rate limit
            current_count = len(self.requests[client_identifier])
            
            if current_count >= self.rate_limit:
                return True, current_count, self.rate_limit
            
            # Add current request
            self.requests[client_identifier].append(current_time)
            
            return False, current_count + 1, self.rate_limit

class RateLimitMiddleware(BaseHTTPMiddleware):
    """Middleware to implement rate limiting"""
    
    def __init__(self, app, rate_limit=100, time_window=60):
        """
        Initialize middleware
        
        Args:
            app: FastAPI app
            rate_limit: Maximum number of requests allowed in the time window
            time_window: Time window in seconds
        """
        super().__init__(app)
        self.rate_limiter = RateLimiter(rate_limit, time_window)
    
    async def dispatch(self, request: Request, call_next):
        # Get client identifier (IP address)
        client_ip = request.client.host
        
        # Check rate limit
        is_limited, current, limit = self.rate_limiter.is_rate_limited(client_ip)
        
        if is_limited:
            logger.warning(f"Rate limit exceeded for client {client_ip}")
            raise HTTPException(
                status_code=429,
                detail="Too many requests. Please try again later."
            )
        
        # Process the request
        response = await call_next(request)
        
        # Add rate limit headers
        response.headers["X-RateLimit-Limit"] = str(limit)
        response.headers["X-RateLimit-Remaining"] = str(limit - current)
        
        return response
```

### 4. Set up proper error handling

Create a file `app/utils/error_handlers.py`:

```python
from fastapi import Request, status
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from starlette.exceptions import HTTPException as StarletteHTTPException
import logging
import traceback
import json
from pydantic import ValidationError

logger = logging.getLogger(__name__)

async def validation_exception_handler(request: Request, exc: RequestValidationError):
    """
    Handle validation errors
    """
    # Log the error details
    logger.warning(f"Validation error: {exc}")
    
    # Extract error details in a clean format
    error_details = []
    for error in exc.errors():
        location = " -> ".join([str(loc) for loc in error["loc"]])
        error_details.append({
            "location": location,
            "message": error["msg"],
            "type": error["type"]
        })
    
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={
            "error": "Validation Error",
            "detail": error_details,
            "request_id": getattr(request.state, "request_id", None)
        }
    )

async def http_exception_handler(request: Request, exc: StarletteHTTPException):
    """
    Handle HTTP exceptions
    """
    logger.warning(f"HTTP exception: {exc.status_code} - {exc.detail}")
    
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "error": "Request error",
            "detail": exc.detail,
            "request_id": getattr(request.state, "request_id", None)
        }
    )

async def general_exception_handler(request: Request, exc: Exception):
    """
    Handle all other exceptions
    """
    # Get request details for logging
    method = request.method
    url = str(request.url)
    client_ip = request.client.host
    
    # Detailed error logging for monitoring
    logger.error(
        f"Unhandled exception: {exc}\n"
        f"Request: {method} {url}\n"
        f"Client: {client_ip}\n"
        f"Request ID: {getattr(request.state, 'request_id', None)}\n"
        f"{traceback.format_exc()}"
    )
    
    # Don't include internal error details in the response
    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content={
            "error": "Internal server error",
            "detail": "An unexpected error occurred",
            "request_id": getattr(request.state, "request_id", None)
        }
    )
```

### 5. Set up CORS and security configurations

Update `app/main.py`:

```python
from fastapi import FastAPI, Depends, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.exceptions import RequestValidationError
from starlette.exceptions import HTTPException as StarletteHTTPException

from app.api import endpoints, auth
from app.db.database import create_tables
from app.utils.security import get_current_active_user
from app.middleware.security import SecurityHeadersMiddleware, RequestIdMiddleware, TimingMiddleware
from app.middleware.rate_limit import RateLimitMiddleware
from app.utils.error_handlers import (
    validation_exception_handler,
    http_exception_handler,
    general_exception_handler
)

# Create FastAPI app
app = FastAPI(
    title="Secure ML API",
    description="Machine Learning API with security best practices",
    version="1.0.0"
)

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://yourdomain.com", "https://www.yourdomain.com"],  # Specify exact origins
    allow_credentials=True,
    allow_methods=["GET", "POST"],  # Limit to necessary methods
    allow_headers=["Authorization", "Content-Type"],
    expose_headers=["X-Request-ID", "X-RateLimit-Limit", "X-RateLimit-Remaining"],
    max_age=86400,  # Cache preflight requests for 24 hours
)

# Add security middlewares
app.add_middleware(SecurityHeadersMiddleware)
app.add_middleware(RequestIdMiddleware)
app.add_middleware(TimingMiddleware)
app.add_middleware(RateLimitMiddleware, rate_limit=100, time_window=60)

# Configure custom error handlers
app.add_exception_handler(RequestValidationError, validation_exception_handler)
app.add_exception_handler(StarletteHTTPException, http_exception_handler)
app.add_exception_handler(Exception, general_exception_handler)

# Create database tables on startup
@app.on_event("startup")
def startup_event():
    create_tables()

# Include routers
app.include_router(auth.router)
app.include_router(
    endpoints.router,
    dependencies=[Depends(get_current_active_user)]
)

# Root endpoint with security info
@app.get("/", include_in_schema=False)
async def root(request: Request):
    """Root endpoint with security headers demonstration"""
    return {
        "message": "Secure ML API",
        "request_id": request.state.request_id,
        "security_headers": "Enabled",
        "authentication": "JWT-based",
        "documentation": "/docs"
    }
```

### 6. Add secure logging

Create a file `app/utils/logging_config.py`:

```python
import logging
import os
import json
from datetime import datetime
import re

class SensitiveDataFilter(logging.Filter):
    """
    Filter to mask sensitive data in logs
    """
    def __init__(self, patterns=None):
        super().__init__()
        self.patterns = patterns or [
            (re.compile(r'(password["\']\s*:\s*["\'])(.+?)(["\'])'), r'\1********\3'),
            (re.compile(r'(Authorization["\']\s*:\s*["\']Bearer\s+)(.+?)(["\'])'), r'\1********\3'),
            (re.compile(r'(api_key["\']\s*:\s*["\'])(.+?)(["\'])'), r'\1********\3'),
            (re.compile(r'(access_token["\']\s*:\s*["\'])(.+?)(["\'])'), r'\1********\3'),
            (re.compile(r'(refresh_token["\']\s*:\s*["\'])(.+?)(["\'])'), r'\1********\3'),
        ]
    
    def filter(self, record):
        if isinstance(record.msg, str):
            for pattern, replacement in self.patterns:
                record.msg = pattern.sub(replacement, record.msg)
        return True

class JSONFormatter(logging.Formatter):
    """
    Format logs as JSON for easier parsing by log management systems
    """
    def format(self, record):
        log_record = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
            "module": record.module,
            "function": record.funcName,
            "line": record.lineno,
            "process": record.process,
            "thread": record.thread,
        }
        
        # Add exception info if available
        if record.exc_info:
            log_record["exception"] = {
                "type": record.exc_info[0].__name__,
                "message": str(record.exc_info[1]),
                "traceback": self.formatException(record.exc_info)
            }
        
        # Add extra attributes
        for key, value in record.__dict__.items():
            if key not in [
                "args", "asctime", "created", "exc_info", "exc_text", "filename",
                "funcName", "id", "levelname", "levelno", "lineno", "module",
                "msecs", "message", "msg", "name", "pathname", "process",
                "processName", "relativeCreated", "stack_info", "thread", "threadName"
            ]:
                log_record[key] = value
        
        return json.dumps(log_record)

def setup_logging():
    """
    Configure logging with security in mind
    """
    # Create logs directory if it doesn't exist
    os.makedirs("logs", exist_ok=True)
    
    # Create handlers
    console_handler = logging.StreamHandler()
    file_handler = logging.FileHandler("logs/app.log")
    security_handler = logging.FileHandler("logs/security.log")
    
    # Set log levels
    console_handler.setLevel(logging.INFO)
    file_handler.setLevel(logging.DEBUG)
    security_handler.setLevel(logging.WARNING)
    
    # Create formatters
    standard_formatter = logging.Formatter(
        '%(asctime)s [%(levelname)s] %(name)s:%(lineno)d - %(message)s'
    )
    json_formatter = JSONFormatter()
    
    # Add formatters to handlers
    console_handler.setFormatter(standard_formatter)
    file_handler.setFormatter(json_formatter)
    security_handler.setFormatter(json_formatter)
    
    # Add sensitive data filter to all handlers
    sensitive_filter = SensitiveDataFilter()
    console_handler.addFilter(sensitive_filter)
    file_handler.addFilter(sensitive_filter)
    security_handler.addFilter(sensitive_filter)
    
    # Configure root logger
    root_logger = logging.getLogger()
    root_logger.setLevel(logging.INFO)
    root_logger.addHandler(console_handler)
    root_logger.addHandler(file_handler)
    
    # Configure security logger
    security_logger = logging.getLogger("security")
    security_logger.setLevel(logging.WARNING)
    security_logger.addHandler(security_handler)
    
    # Configure FastAPI logger
    fastapi_logger = logging.getLogger("fastapi")
    fastapi_logger.setLevel(logging.INFO)
    
    # Configure uvicorn access logger
    uvicorn_logger = logging.getLogger("uvicorn.access")
    uvicorn_logger.setLevel(logging.INFO)
    
    return root_logger

# Initialize logging
logger = setup_logging()
```

Update the auth module in `app/api/auth.py` to use secure logging:

```python
# Add at the top of the file
from app.utils.logging_config import logger as app_logger
import logging

# Create a security logger
security_logger = logging.getLogger("security")

# Update login function
@router.post("/token", response_model=Token)
def login_for_access_token(request: Request, form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):
    """
    Authenticate and generate JWT token
    """
    user = authenticate_user(db, form_data.username, form_data.password)
    
    # Log authentication attempt
    client_ip = request.client.host
    if user:
        security_logger.info(
            f"Successful login: user={form_data.username}, ip={client_ip}, "
            f"request_id={request.state.request_id}"
        )
    else:
        security_logger.warning(
            f"Failed login attempt: user={form_data.username}, ip={client_ip}, "
            f"request_id={request.state.request_id}"
        )
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.email, "role": user.role}, 
        expires_delta=access_token_expires
    )
    
    return {"access_token": access_token, "token_type": "bearer"}
```

## Examples of usage

### 1. Testing Input Validation

```python
import requests

# Test with valid data
response = requests.post(
    "http://localhost:8000/auth/token",
    data={
        "username": "user@example.com",
        "password": "SecureP@ss123"
    }
)

token = response.json()["access_token"]
headers = {"Authorization": f"Bearer {token}"}

# Test with valid prediction data
valid_data = {
    "sepal_length": 5.1,
    "sepal_width": 3.5,
    "petal_length": 1.4,
    "petal_width": 0.2
}

response = requests.post(
    "http://localhost:8000/predict",
    headers=headers,
    json=valid_data
)

print("Valid data response:", response.status_code)
print(response.json())

# Test with invalid data (negative value)
invalid_data = {
    "sepal_length": -5.1,  # Negative value, should be rejected
    "sepal_width": 3.5,
    "petal_length": 1.4,
    "petal_width": 0.2
}

response = requests.post(
    "http://localhost:8000/predict",
    headers=headers,
    json=invalid_data
)

print("Invalid data response:", response.status_code)
print(response.json())

# Test with biologically implausible data
implausible_data = {
    "sepal_length": 5.1,
    "sepal_width": 12.0,  # Too wide compared to length
    "petal_length": 1.4,
    "petal_width": 0.2
}

response = requests.post(
    "http://localhost:8000/predict",
    headers=headers,
    json=implausible_data
)

print("Implausible data response:", response.status_code)
print(response.json())
```

### 2. Testing Rate Limiting

```python
import requests
import time
import concurrent.futures

def make_request(url, headers):
    """Make a request and return the response"""
    response = requests.get(url, headers=headers)
    return {
        "status_code": response.status_code,
        "headers": {
            "X-RateLimit-Limit": response.headers.get("X-RateLimit-Limit"),
            "X-RateLimit-Remaining": response.headers.get("X-RateLimit-Remaining")
        }
    }

# Authenticate to get a token
response = requests.post(
    "http://localhost:8000/auth/token",
    data={
        "username": "user@example.com",
        "password": "SecureP@ss123"
    }
)

token = response.json()["access_token"]
headers = {"Authorization": f"Bearer {token}"}

# Make multiple requests in parallel to trigger rate limiting
url = "http://localhost:8000/info"
num_requests = 110  # More than our rate limit (100)

print(f"Making {num_requests} requests to test rate limiting...")

with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
    futures = [executor.submit(make_request, url, headers) for _ in range(num_requests)]
    
    # Process results as they complete
    for i, future in enumerate(concurrent.futures.as_completed(futures)):
        result = future.result()
        print(f"Request {i+1}: Status={result['status_code']}, Limit={result['headers']['X-RateLimit-Limit']}, Remaining={result['headers']['X-RateLimit-Remaining']}")
        
        # If we hit rate limit, show the error
        if result['status_code'] == 429:
            print("Rate limit exceeded!")
```

### 3. Examining Security Headers

```python
import requests

# Make a request to the API
response = requests.get("http://localhost:8000/")

# Print all headers
print("Response Headers:")
for header, value in response.headers.items():
    print(f"{header}: {value}")

# Check for specific security headers
security_headers = [
    "X-Content-Type-Options",
    "X-Frame-Options",
    "X-XSS-Protection",
    "Strict-Transport-Security",
    "Content-Security-Policy",
    "X-Request-ID"
]

print("\nSecurity Headers Check:")
for header in security_headers:
    if header in response.headers:
        print(f"✅ {header}: {response.headers[header]}")
    else:
        print(f"❌ {header}: Missing")
```

## Tasks for students

1. **Implement Comprehensive Input Validation with Pydantic**
   - Enhance the Pydantic models with stricter validation rules
   - Add custom validators to check for biologically plausible values
   - Implement validation for batch prediction requests
   - Test the validation with valid and invalid inputs

2. **Set Up Proper Error Handling and Security Logging**
   - Implement custom exception handlers for various error types
   - Create a secure logging system that masks sensitive data
   - Add structured JSON logging for better analysis
   - Test different error scenarios to ensure proper handling

3. **Implement Request Throttling/Rate Limiting**
   - Create a sliding window rate limiter middleware
   - Add rate limiting headers to API responses
   - Test rate limiting with concurrent requests
   - Add monitoring for rate limit violations

## Solution (for instructors)

### Solution for Task 1: Input Validation

The key points to evaluate in student solutions:

1. Proper use of Pydantic's validation features (min/max values, regex, etc.)
2. Custom validators for checking realistic values
3. Comprehensive validation of all input fields
4. Domain-specific validation (e.g., biological plausibility checks)

Students should have used Pydantic's validation features, created custom validators, and implemented validation for all input fields.

### Solution for Task 2: Error Handling and Logging

The key points to evaluate in student solutions:

1. Custom exception handlers for different error types
2. Sensitive data filtering in logs
3. Structured JSON logging format
4. Proper logging of security events

Students should have implemented custom exception handlers, created a secure logging system, and added structured JSON logging.

### Solution for Task 3: Rate Limiting

The key points to evaluate in student solutions:

1. Sliding window implementation for rate limiting
2. Thread-safe implementation
3. Proper rate limit headers
4. Appropriate error responses (429)

Students should have implemented a sliding window rate limiter, added rate limiting headers, and handled rate limit violations properly.

### Complete API Security Implementation Script

```python
"""
Complete solution script for API security best practices implementation
"""

# ----- app/models/models.py -----
from pydantic import BaseModel, Field, validator, confloat
from typing import List, Dict, Any, Optional
import re

class IrisFeatures(BaseModel):
    """Input features for Iris prediction"""
    sepal_length: confloat(gt=0, lt=15) = Field(..., description="Sepal length in cm")
    sepal_width: confloat(gt=0, lt=15) = Field(..., description="Sepal width in cm")
    petal_length: confloat(gt=0, lt=15) = Field(..., description="Petal length in cm")
    petal_width: confloat(gt=0, lt=15) = Field(..., description="Petal width in cm")
    
    @validator('*')
    def check_realistic_values(cls, v, values, **kwargs):
        """Ensure values are within realistic ranges for iris flowers"""
        field = kwargs['field'].name
        
        # Check combinations of values for biological plausibility
        if field == 'petal_width' and 'petal_length' in values:
            if v > values['petal_length']:
                raise ValueError('Petal width cannot be greater than petal length')
        
        if field == 'sepal_width' and 'sepal_length' in values:
            if v > values['sepal_length'] * 2:
                raise ValueError('Sepal width is unrealistically large compared to length')
                
        return v
    
    class Config:
        schema_extra = {
            "example": {
                "sepal_length": 5.1,
                "sepal_width": 3.5,
                "petal_length": 1.4,
                "petal_width": 0.2
            }
        }

class BatchPredictionRequest(BaseModel):
    """Batch prediction request"""
    instances: List[IrisFeatures] = Field(..., min_items=1, max_items=100)
    
    class Config:
        schema_extra = {
            "example": {
                "instances": [
                    {
                        "sepal_length": 5.1,
                        "sepal_width": 3.5,
                        "petal_length": 1.4,
                        "petal_width": 0.2
                    },
                    {
                        "sepal_length": 6.3,
                        "sepal_width": 3.3,
                        "petal_length": 4.7,
                        "petal_width": 1.6
                    }
                ]
            }
        }

class PredictionResponse(BaseModel):
    """API response for a prediction"""
    prediction: List[str]
    probability: List[float] = None
    model_version: str
    request_id: Optional[str] = None

class BatchPredictionResponse(BaseModel):
    """API response for batch predictions"""
    predictions: List[str]
    probabilities: Optional[List[List[float]]] = None
    model_version: str
    count: int
    request_id: Optional[str] = None

# ----- app/middleware/security.py -----
from fastapi import Request
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import Response
import time
import uuid

class SecurityHeadersMiddleware(BaseHTTPMiddleware):
    """Middleware to add security headers to responses"""
    
    async def dispatch(self, request: Request, call_next):
        # Process the request
        response = await call_next(request)
        
        # Add security headers
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains"
        response.headers["Content-Security-Policy"] = "default-src 'self'"
        
        return response

class RequestIdMiddleware(BaseHTTPMiddleware):
    """Middleware to add unique request IDs for tracking"""
    
    async def dispatch(self, request: Request, call_next):
        # Generate unique request ID
        request_id = str(uuid.uuid4())
        
        # Add request ID to request state
        request.state.request_id = request_id
        
        # Process the request
        response = await call_next(request)
        
        # Add request ID to response headers
        response.headers["X-Request-ID"] = request_id
        
        return response

class TimingMiddleware(BaseHTTPMiddleware):
    """Middleware to add server timing headers"""
    
    async def dispatch(self, request: Request, call_next):
        # Record start time
        start_time = time.time()
        
        # Process the request
        response = await call_next(request)
        
        # Calculate processing time
        process_time = time.time() - start_time
        
        # Add timing header
        response.headers["Server-Timing"] = f"total;dur={process_time*1000:.2f}"
        
        return response

# ----- app/middleware/rate_limit.py -----
from fastapi import Request, HTTPException
from starlette.middleware.base import BaseHTTPMiddleware
import time
import logging
from collections import defaultdict
import threading

logger = logging.getLogger(__name__)

class RateLimiter:
    """Rate limiting implementation using sliding window"""
    
    def __init__(self, rate_limit, time_window):
        """
        Initialize rate limiter
        
        Args:
            rate_limit: Maximum number of requests allowed in the time window
            time_window: Time window in seconds
        """
        self.rate_limit = rate_limit
        self.time_window = time_window
        self.requests = defaultdict(list)  # client_identifier -> list of request timestamps
        self.lock = threading.Lock()
    
    def is_rate_limited(self, client_identifier):
        """
        Check if client is rate limited
        
        Args:
            client_identifier: Unique client identifier (e.g., IP address)
            
        Returns:
            tuple: (is_limited, current_count, limit)
        """
        with self.lock:
            # Get current time
            current_time = time.time()
            
            # Clean up old requests
            self.requests[client_identifier] = [
                timestamp for timestamp in self.requests[client_identifier] 
                if current_time - timestamp < self.time_window
            ]
            
            # Check rate limit
            current_count = len(self.requests[client_identifier])
            
            if current_count >= self.rate_limit:
                return True, current_count, self.rate_limit
            
            # Add current request
            self.requests[client_identifier].append(current_time)
            
            return False, current_count + 1, self.rate_limit

class RateLimitMiddleware(BaseHTTPMiddleware):
    """Middleware to implement rate limiting"""
    
    def __init__(self, app, rate_limit=100, time_window=60):
        """
        Initialize middleware
        
        Args:
            app: FastAPI app
            rate_limit: Maximum number of requests allowed in the time window
            time_window: Time window in seconds
        """
        super().__init__(app)
        self.rate_limiter = RateLimiter(rate_limit, time_window)
    
    async def dispatch(self, request: Request, call_next):
        # Get client identifier (IP address)
        client_ip = request.client.host
        
        # Check rate limit
        is_limited, current, limit = self.rate_limiter.is_rate_limited(client_ip)
        
        if is_limited:
            logger.warning(f"Rate limit exceeded for client {client_ip}")
            raise HTTPException(
                status_code=429,
                detail="Too many requests. Please try again later."
            )
        
        # Process the request
        response = await call_next(request)
        
        # Add rate limit headers
        response.headers["X-RateLimit-Limit"] = str(limit)
        response.headers["X-RateLimit-Remaining"] = str(limit - current)
        
        return response

# ----- app/utils/error_handlers.py -----
from fastapi import Request, status
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from starlette.exceptions import HTTPException as StarletteHTTPException
import logging
import traceback
import json
from pydantic import ValidationError

logger = logging.getLogger(__name__)

async def validation_exception_handler(request: Request, exc: RequestValidationError):
    """
    Handle validation errors
    """
    # Log the error details
    logger.warning(f"Validation error: {exc}")
    
    # Extract error details in a clean format
    error_details = []
    for error in exc.errors():
        location = " -> ".join([str(loc) for loc in error["loc"]])
        error_details.append({
            "location": location,
            "message": error["msg"],
            "type": error["type"]
        })
    
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={
            "error": "Validation Error",
            "detail": error_details,
            "request_id": getattr(request.state, "request_id", None)
        }
    )

async def http_exception_handler(request: Request, exc: StarletteHTTPException):
    """
    Handle HTTP exceptions
    """
    logger.warning(f"HTTP exception: {exc.status_code} - {exc.detail}")
    
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "error": "Request error",
            "detail": exc.detail,
            "request_id": getattr(request.state, "request_id", None)
        }
    )

async def general_exception_handler(request: Request, exc: Exception):
    """
    Handle all other exceptions
    """
    # Get request details for logging
    method = request.method
    url = str(request.url)
    client_ip = request.client.host
    
    # Detailed error logging for monitoring
    logger.error(
        f"Unhandled exception: {exc}\n"
        f"Request: {method} {url}\n"
        f"Client: {client_ip}\n"
        f"Request ID: {getattr(request.state, 'request_id', None)}\n"
        f"{traceback.format_exc()}"
    )
    
    # Don't include internal error details in the response
    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content={
            "error": "Internal server error",
            "detail": "An unexpected error occurred",
            "request_id": getattr(request.state, "request_id", None)
        }
    )

# ----- app/utils/logging_config.py -----
import logging
import os
import json
from datetime import datetime
import re

class SensitiveDataFilter(logging.Filter):
    """
    Filter to mask sensitive data in logs
    """
    def __init__(self, patterns=None):
        super().__init__()
        self.patterns = patterns or [
            (re.compile(r'(password["\']\s*:\s*["\'])(.+?)(["\'])'), r'\1********\3'),
            (re.compile(r'(Authorization["\']\s*:\s*["\']Bearer\s+)(.+?)(["\'])'), r'\1********\3'),
            (re.compile(r'(api_key["\']\s*:\s*["\'])(.+?)(["\'])'), r'\1********\3'),
            (re.compile(r'(access_token["\']\s*:\s*["\'])(.+?)(["\'])'), r'\1********\3'),
            (re.compile(r'(refresh_token["\']\s*:\s*["\'])(.+?)(["\'])'), r'\1********\3'),
        ]
    
    def filter(self, record):
        if isinstance(record.msg, str):
            for pattern, replacement in self.patterns:
                record.msg = pattern.sub(replacement, record.msg)
        return True

class JSONFormatter(logging.Formatter):
    """
    Format logs as JSON for easier parsing by log management systems
    """
    def format(self, record):
        log_record = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
            "module": record.module,
            "function": record.funcName,
            "line": record.lineno,
            "process": record.process,
            "thread": record.thread,
        }
        
        # Add exception info if available
        if record.exc_info:
            log_record["exception"] = {
                "type": record.exc_info[0].__name__,
                "message": str(record.exc_info[1]),
                "traceback": self.formatException(record.exc_info)
            }
        
        # Add extra attributes
        for key, value in record.__dict__.items():
            if key not in [
                "args", "asctime", "created", "exc_info", "exc_text", "filename",
                "funcName", "id", "levelname", "levelno", "lineno", "module",
                "msecs", "message", "msg", "name", "pathname", "process",
                "processName", "relativeCreated", "stack_info", "thread", "threadName"
            ]:
                log_record[key] = value
        
        return json.dumps(log_record)

def setup_logging():
    """
    Configure logging with security in mind
    """
    # Create logs directory if it doesn't exist
    os.makedirs("logs", exist_ok=True)
    
    # Create handlers
    console_handler = logging.StreamHandler()
    file_handler = logging.FileHandler("logs/app.log")
    security_handler = logging.FileHandler("logs/security.log")
    
    # Set log levels
    console_handler.setLevel(logging.INFO)
    file_handler.setLevel(logging.DEBUG)
    security_handler.setLevel(logging.WARNING)
    
    # Create formatters
    standard_formatter = logging.Formatter(
        '%(asctime)s [%(levelname)s] %(name)s:%(lineno)d - %(message)s'
    )
    json_formatter = JSONFormatter()
    
    # Add formatters to handlers
    console_handler.setFormatter(standard_formatter)
    file_handler.setFormatter(json_formatter)
    security_handler.setFormatter(json_formatter)
    
    # Add sensitive data filter to all handlers
    sensitive_filter = SensitiveDataFilter()
    console_handler.addFilter(sensitive_filter)
    file_handler.addFilter(sensitive_filter)
    security_handler.addFilter(sensitive_filter)
    
    # Configure root logger
    root_logger = logging.getLogger()
    root_logger.setLevel(logging.INFO)
    root_logger.addHandler(console_handler)
    root_logger.addHandler(file_handler)
    
    # Configure security logger
    security_logger = logging.getLogger("security")
    security_logger.setLevel(logging.WARNING)
    security_logger.addHandler(security_handler)
    
    # Configure FastAPI logger
    fastapi_logger = logging.getLogger("fastapi")
    fastapi_logger.setLevel(logging.INFO)
    
    # Configure uvicorn access logger
    uvicorn_logger = logging.getLogger("uvicorn.access")
    uvicorn_logger.setLevel(logging.INFO)
    
    return root_logger

# ----- app/main.py -----
from fastapi import FastAPI, Depends, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.exceptions import RequestValidationError
from starlette.exceptions import HTTPException as StarletteHTTPException

from app.api import endpoints, auth
from app.db.database import create_tables
from app.utils.security import get_current_active_user
from app.middleware.security import SecurityHeadersMiddleware, RequestIdMiddleware, TimingMiddleware
from app.middleware.rate_limit import RateLimitMiddleware
from app.utils.error_handlers import (
    validation_exception_handler,
    http_exception_handler,
    general_exception_handler
)
from app.utils.logging_config import setup_logging

# Set up logging
logger = setup_logging()

# Create FastAPI app
app = FastAPI(
    title="Secure ML API",
    description="Machine Learning API with security best practices",
    version="1.0.0"
)

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://yourdomain.com", "https://www.yourdomain.com"],  # Specify exact origins
    allow_credentials=True,
    allow_methods=["GET", "POST"],  # Limit to necessary methods
    allow_headers=["Authorization", "Content-Type"],
    expose_headers=["X-Request-ID", "X-RateLimit-Limit", "X-RateLimit-Remaining"],
    max_age=86400,  # Cache preflight requests for 24 hours
)

# Add security middlewares
app.add_middleware(SecurityHeadersMiddleware)
app.add_middleware(RequestIdMiddleware)
app.add_middleware(TimingMiddleware)
app.add_middleware(RateLimitMiddleware, rate_limit=100, time_window=60)

# Configure custom error handlers
app.add_exception_handler(RequestValidationError, validation_exception_handler)
app.add_exception_handler(StarletteHTTPException, http_exception_handler)
app.add_exception_handler(Exception, general_exception_handler)

# Create database tables on startup
@app.on_event("startup")
def startup_event():
    create_tables()
    logger.info("Started API with security features enabled")

# Include routers
app.include_router(auth.router)
app.include_router(
    endpoints.router,
    dependencies=[Depends(get_current_active_user)]
)

# Root endpoint with security info
@app.get("/", include_in_schema=False)
async def root(request: Request):
    """Root endpoint with security headers demonstration"""
    logger.info(f"Root endpoint accessed, request_id={request.state.request_id}")
    return {
        "message": "Secure ML API",
        "request_id": request.state.request_id,
        "security_headers": "Enabled",
        "authentication": "JWT-based",
        "documentation": "/docs"
    }

# Shutdown event
@app.on_event("shutdown")
def shutdown_event():
    logger.info("API shutting down")
```